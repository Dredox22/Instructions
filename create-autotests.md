# Инструкция по созданию автотестов

1. [Общее](#Общее)
2. [Автотесты для SQL](#автотесты-для-sql)
3. [Автотесты для других языков программирования](#автотесты-для-других-языков-программирования)

## Общее

1. Автотесты создаются в файлах формата `test_N.py`. Здесь `N` - номер задачи из базы данных.
2. Если нужно добавить к задаче отдельные файлы, убираем их в папку `files/all`.

**Примечание:** Если вы просто добавляете файл, то во время решения задачи для пользователя он будет «лежать» в той же папке, откуда запускается скрипт.

Пример:

```python
# Предположим, мы добавили в папку files/all файл «1.txt»
# Попробуем выполнить код

with open('1.txt', 'r') as f:
    print(f.read())

# Этот код отработает корректно
```

3. Если к задаче нужно добавить файл, который якобы лежит в какой-то папке, то всю структуру папок нужно поместить в `files/all`.

Например, в задаче нужно открыть файл `./users/1/myfile.csv`, который лежит в папке `./users/1`. Тогда необходимо в папку `files/all` добавить подпапки `users/1`, а в них нужный файл `myfile.csv`. Тогда сработает, например, такой код:

```python
with open('./users/1/myfile.csv', 'r') as f:
    print(f.read())
```

4. Не создавайте задачи, в которых используется функция `input` (или другие функции, ожидающие ввод данных с клавиатуры) - такое мы не обрабатываем в текущей версии.

**Примечание для корпоративных клиентов**

Вам нужно передавать файлы с тестами, а также файлы/папки (описанные в п. 2-3) сотрудникам IT Resume. Они загрузят это в соответствующие репозитории.

## Автотесты для SQL

### Базовая структура теста

Файл `test_N.py` для задачи по SQL должен выглядеть так:

```python
import os
import sys

dirname = os.path.dirname(__file__)
module_path = os.path.join(dirname, "..")
sys.path.append(module_path)

from AbstractTest2 import AbstractTest2, RunCode, process, wrapper

CORRECT_QUERY = """
select
	user_id,
	count(distinct case when is_false = 0 then problem_id end) as cnt
from codesubmit c
group by user_id
"""


class Tests(AbstractTest2):
    def test_1(self):
        self.sql_test(
            correct_query=CORRECT_QUERY,
            user="simulative",
            ignore_order=True
        )

    def test_2(self):
        self.code_contains_test(s="union")
```

Разберем по шагам:

### Необходимые импорты

Первые несколько строк - это просто необходимые импорты, которые нужно прописывать всегда для таких задач.

```python
import os
import sys

dirname = os.path.dirname(__file__)
module_path = os.path.join(dirname, "..")
sys.path.append(module_path)

from AbstractTest2 import AbstractTest2, RunCode, process, wrapper
```

### Эталонное решение

В переменную `CORRECT_QUERY` нужно записать эталонное решение. Это код, который дает правильное решение задачи.

**Важно:** Именно с результатом этого запроса будет сравниваться ответ, который получится в результате выполнения кода пользователя.

```python
CORRECT_QUERY = """
select
	user_id,
	count(distinct case when is_false = 0 then problem_id end) as cnt
from codesubmit c
group by user_id
"""
```

### Класс с тестами

Основная часть автопроверки - класс `Tests` с описанными тестами внутри. Каждый отдельный тест имеет название `test_1`, `test_2` и так далее.

**Важно:** Следите, чтобы разные тесты имели разные индексы. Не должно быть, например, двух тестов с одинаковым именем `test_i` - иначе будет выполнена только одна из двух проверок.

```python
class Tests(AbstractTest2):
    def test_1(self):
        ...

    def test_2(self):
        ...
```

**Примечание:** Число тестов может быть бесконечным.

Однако, мы говорим именно про SQL, а для таких задач есть только 2 вида тестов:

1. Проверка результата
2. Проверка - содержит ли решение пользователя конкретную подстроку (например, какой-то оператор)

Рассмотрим каждый вид тестов подробней.

### Проверка результата

Первым тестом для SQL-задач всегда идет проверка правильности результата. Такой тест нужно определять внутри метода `test_1` внутри класса `Tests`:

```python
class Tests(AbstractTest2):
    def test_1(self):
        # Базовый тест, который сравнивает результат эталонного запроса и запроса, который напишет пользователь.
        # Дополнительно при этом будут проверяться:
        # 1. Количество строк в результате
        # 2. Типы данных в каждом столбце
        self.sql_test(
            correct_query=CORRECT_QUERY,
        )
```

Этот тест делает сразу несколько проверок:

* Проверяет правильность решения задачи. Таблица, полученная в результате выполнения кода пользователя, сравнивается с таблицей, которая получается при выполнении эталонного решения.

**Примечание:** Результаты сравниваются построчно.

* Проверяет общее количество строк в ответе пользователя и сравнивает с эталонным ответом.
* Проверяет типы данных для каждого столбца, сравнивая с эталонным ответом.

При необходимости, можно задать 2 дополнительных аргумента:

* `user='{username}'` - если таблица находится в какой-то специфической базе данных
* `ignore_order=True` - если в задаче не выдвигается требований к сортировке результата (т.е. ответ пользователя может быть отсортирован как угодно)

**Примечания:**

1. Некоторые структуры данных временно не поддерживают сортировку на уровне нашей тестирующей системы. Старайтесь в таких задачах явно указывать правило сортировки. Примеры таких структур данных: массивы в PostgreSQL, json-поля в PostgreSQL.
2. Если аргументы `user` и `ignore_order` вам не нужны, то просто их не указывайте. По умолчанию идет стандартный пользователь и `ignore_order=False` (т.е. предполагается, что студент сам указал правило сортировки с помощью `order by` в своем решении)

**Примеры:**

Если нужно указать только пользователя:

```python
class Tests(AbstractTest2):
    def test_1(self):
        self.sql_test(
            correct_query=CORRECT_QUERY,
            user="simulative", # Необязательный аргумент. Используется для корпоративных клиентов. Для обычных задач можно удалить этот аргумент.
        )
```

Если нужно указать только необходимости сортировки:

```python
class Tests(AbstractTest2):
    def test_1(self):
        self.sql_test(
            correct_query=CORRECT_QUERY,
            ignore_order=True, # Необязательный аргумент. Указываем, если при проверке запроса нам не принципиален порядок строк.
        )
```

Если нужно и то, и другое:

```python
class Tests(AbstractTest2):
    def test_1(self):
        self.sql_test(
            correct_query=CORRECT_QUERY,
            user="simulative",
            ignore_order=True,
        )
```

**Важно:** Тест `sql_test` нужно указывать только один раз для одной задачи.

### Проверка наличия подстроки

Иногда возникают задачи вида:

> Проверить, что задача решена именно с помощью оператора `UNION`

В таком случае у нас есть специальный тест, который проверяет вхождение нужной подстроки в решение пользователя - `code_contains_test`:

```python
class Tests(AbstractTest2):
    def test_1(self):
        ...

    def test_2(self):
        # Такой тест можно добавить, если решение пользователя должно содержать вхождение конкретной подстроки.
        # Например, оператора union
        # Проверка регистронезависимая
        self.code_contains_test(s="union")

    def test_3(self):
        # Можно добавлять несколько таких тестов
        self.code_contains_test(s="select")
```

В таком случае проверяется, есть ли указанная подстрока в решении пользователя.

**Примечание:** Будьте осторожны: проверка идет во всему решению - даже если пользователь просто указал нужное слово в комментариях или если оно встретилось в качестве подстроки в другом слове.

Например, мы указали `code_contains_test(s="union")`. В таком случае все эти решения пройдут данный тест:

```sql
-- Вариант 1, действительно есть такой оператор
select 1
union all
select 2

-- Вариант 2, в решении оператора нет, но он указан в комментах

select 1
from table -- ха, я обманул систему и тут есть union :)

-- Вариант 3, в решении оператора нет, но такое слово входит в состав другого

select 1 as union_field
from table
```

**Примечание:** Поиск регистронезависимый - `union`, `UNION` и даже `unIOn` дадут абсолютно одинаковый результат.

**Примечание:** Таких тестов на наличие подстроки можно добавлять сколько угодно. Но будьте осторожны - если вдруг пользователь решит задачу с помощью других операторов, то он не сможет пройти ваш тест. Добавляйте их только если это действительно важно.



## Автотесты для других языков программирования

### Базовая структура теста

Файл `test_N.py` для задачи по Python/JavaScript/другому языку программирования должен выглядеть так:

```python
import os
import sys

dirname = os.path.dirname(__file__)
module_path = os.path.join(dirname, "..")
sys.path.append(module_path)

from AbstractTest2 import AbstractTest2, RunCode, process, wrapper

CORRECT_CODE = r"""
...
"""

CORRECT_CODE_LANGUAGE = "Python"


class Tests(AbstractTest2):
    def test_1(self):
        class_name = ""
        class_args = ""
        method_name = "l_p"
        var_name = ""
        attr_name = ""
        need_to_eval = False
        formulation = ""
        need_print = True
        add_before = ""
        add_after = ""

        arguments = {
            "my_dict": {
                "try1": ["33", "Nikita"],
                "try2": ["333", "Nikita^-^"],
                "try3": ["Nikita^-^", "33"],
                "try4": ["Nikita", "33"],
            }
        }

        fake_arguments = {}

        self.default_test(
            class_name=class_name,
            class_args=class_args,
            method_name=method_name,
            attr_name=attr_name,
            need_to_eval=need_to_eval,
            arguments=arguments,
            fake_arguments=fake_arguments,
            correct_code=CORRECT_CODE,
            correct_code_language=CORRECT_CODE_LANGUAGE,
            var_name=var_name,
            formulation=formulation,
            need_print=need_print,
            add_before=add_before,
            add_after=add_after,
        )

    def test_2(self):
        ...

    def test_3(self):
        ...
```

Разберем по шагам.

### Необходимые импорты

Первые несколько строк - необходимые импорты, которые нужно указывать в каждом файле:

```python
import os
import sys

dirname = os.path.dirname(__file__)
module_path = os.path.join(dirname, "..")
sys.path.append(module_path)

from AbstractTest2 import AbstractTest2, RunCode, process, wrapper
```

### Эталонное решение

Далее в переменную `CORRECT_CODE` записывается эталонный ответ на задачу. Это код, который даст правильный результат на все проверки. Также необходимо записать язык программирования, на котором приведен эталонный ответ, в переменную `CORRECT_CODE_LANGUAGE`.

```python
CORRECT_CODE = r"""
...
"""

CORRECT_CODE_LANGUAGE = "Python"
```

**Примечание:** Переменная `CORRECT_CODE_LANGUAGE` нужна, т.к. вы можете указать эталонное решение на одном языке, а пользователи смогут решать задачу сразу на нескольких. Например, ваше эталонное решение на Python, а решение пользователя может быть на C++.

Возможные варианты `CORRECT_CODE_LANGUAGE`:

* Python
* JavaScript
* Java
* C++

**Примечание:** Соблюдайте регистр букв, как в списке выше. Например, `JavaScript` и `Javascript` - разные вещи. И уж тем более `JavaScript` и `JS` :)

**Важно:** Если вы делаете задачу, для которой предполагается, что пользователь сможет решать ее на разных языках, то старайтесь формулировать такие задачи таким образом, чтобы в ответе получались стандартные типы данных: строки, числа, стандартные массивы или булевские переменные (`True/False`). Любые более специфические переменные могут привести к ошибкам проверки, если эталонное решение и решение пользователя написано на разных языках.




**Важно:** Каждый тест должен проверять одну переменную, один метод, один класс или какую-то другую одну сущность. Не пишите «многопрофильные» тесты, которые проверяют все и сразу. Подробнее о том, как проверять разные сущности - ниже.

### Класс с тестами

Далее, после определения эталонного решения, идет класс с тестами. Структурно там все по аналогии с SQL:

* Класс называется `Tests`
* Каждый отдельный тест записывается в метод `test_i`, где `i` - номер теста
* Тестов может быть бесконечно много
* Каждый тест должен осуществлять какую-то одну проверку

Пример:

```python
class Tests(AbstractTest2):
    def test_1(self):
        ...

    def test_2(self):
        ...

    def test_3(self):
        ...
```

Внутри каждый тест состоит из нескольких переменных, с помощью которых и задается итоговая проверка. Подробнее эти переменные мы рассмотрим ниже.

В конце каждого теста идет вызов `default_test` - именно он и инициирует проверку кода пользователя. Его трогать не нужно, он всегда должен оставаться одинаковым:

```python
class Tests(AbstractTest2):
    def test_1(self):
        # здесь идет определение переменных - об этом поговорим ниже

        # вызов метода default_test - этот блок никогда не меняем
        self.default_test(
            class_name=class_name,
            class_args=class_args,
            method_name=method_name,
            attr_name=attr_name,
            need_to_eval=need_to_eval,
            arguments=arguments,
            fake_arguments=fake_arguments,
            correct_code=CORRECT_CODE,
            correct_code_language=CORRECT_CODE_LANGUAGE,
            var_name=var_name,
            formulation=formulation,
            need_print=need_print,
            add_before=add_before,
            add_after=add_after,
        )
```

### Конфигурационные переменные

Каждый тест создается с помощью конфигурационных переменных. Именно с помощью них мы можем задать:

* какой класс/метод/переменную/атрибут нам нужно проверить
* есть ли в задании функция `print` (или ее аналоги из других языков программирования)
* какие переменные нужно передать в класс/метод/функцию
* нужно ли дополнительно делать какие-то преобразования с кодом
* и так далее

Давайте для начала рассмотрим, за что отвечает каждая переменная и в каких ситуациях их имеет смысл использовать. А после этого рассмотрим автотесты для типовых задач.

#### Имя класса

Если в задаче пользователь должен создать класс с определенным именем, а в тесте мы хотим проверить этот класс/его метод/атрибут, то нужно указать название этого класса в переменную `class_name`.

Если в данном тесте класс не проверяется, то укажите просто пустые кавычки.

Пример:

```python
class_name = "Answer" # в тесте будет проверяться класс Answer
class_name = "" # класс в тесте проверяться не будет
```

#### Аргументы класса

Если при создании класса, который описан в `class_name` необходимо передать какие-то аргументы (в конструктор класса), то такие аргументы нужно записать в переменную `class_args`.

Переменную `class_args` необходимо создать в виде словаря. Ключи этого словаря - имена переменных. Значения - соответствующие этим ключам значения.

**Примечание:** В `class_args` можно также передавать позиционные аргументы, т.е. аргументы без имени. Для этого им нужно задать имя формата `__itresume_noname_i`.

Примеры:

```python
class_name = "Answer"

class_args = {
    'name': 'IT Resume',
    'cnt': 5,
    'myarr': [1, 2, 3, 4, 5],
    'mydict': {
        1: "a",
        2: "b",
        3: "c"
    },
    '__itresume_noname_1': 'первый аргумент без имени',
    '__itresume_noname_2': 2,
}
```

На этапе проверке такая конструкция будет переформатирована в следующий код:

```python
# Обратите внимание, здесь создается экземпляр класса `Answer`
# При этом в него передаются сначала позиционные аргументы (без имени)
# А затем именованные
Answer(
    'первый аргумент без имени',
    2,
    name='IT Resume',
    cnt=5,
    myarr=[1, 2, 3, 4, 5],
    mydict={
        1: "a",
        2: "b",
        3: "c"
    }
)
```

Если аргументы в класс передавать не надо, то просто задаем пустую строку:

```python
class_args = ""
```

#### Имя метода или функции

Если в тесте необходимо проверить функцию или метод в каком-то классе, то нужно задать название такой функции или метода в переменной `method_name`. Иначе просто задаем пустую строку.

Например, если нам нужно проверить функцию `foo`:

```python
class_name = ""
class_args = ""

method_name = "foo"
```

Или если нужно проверить метод `foo` в классе `Bar`:

```python
class_name = "Bar"
class_args = ""

method_name = "foo"
```

Если вообще не нужно проверять метод/функцию:

```python
method_name = ''
```


#### Аргументы метода/функции

Часто возникает необходимость передать в функцию при проверке определенные аргументы. Это можно сделать, определив словари `arguments` и `fake_arguments`.

Словарь `arguments` задается полностью аналогично `class_args`. Только если аргументы передавать не нужно - оставляем не пустую строку, а пустой словарь `{}`.

Пример:

```python
class_name = "Bar"
class_args = ""

method_name = "foo"

arguments = {
    'name': 'IT Resume',
    'cnt': 5,
    'myarr': [1, 2, 3, 4, 5],
    'mydict': {
        1: "a",
        2: "b",
        3: "c"
    },
    '__itresume_noname_1': 'первый аргумент без имени',
    '__itresume_noname_2': 2,
}
```

При таком задании аргументов на этапе проверке будет проверяться метод `foo` из класса `Bar`, при этом в метод `foo` будут переданы все указанные аргументы:

```python
Bar().foo(
    'первый аргумент без имени',
    2,
    name='IT Resume',
    cnt=5,
    myarr=[1, 2, 3, 4, 5],
    mydict={
        1: "a",
        2: "b",
        3: "c"
    }
)
```

Если нужно оставить пустым:

```python
arguments = {}
```

Однако, иногда аргументы, которые нужно передать в функцию/метод нельзя задать вручную - они являются результатом выполнения предыдущего кода пользователя. Например, рассмотрим такую задачу:

> Прочитайте из файла датафрейм в переменную df. Затем создайте функцию `foo` и передайте в качестве аргумента `row` первую строку этого датафрейма.

В таком случае, где-то в своем коде пользователь создает переменную `df`, а вам нужно передать в аргументах `df.iloc[1, :]`. Если вы попробуете указать такую конструкцию, то получите ошибку, что переменная `df` не определена:

```python
arguments = {
    'df': df.iloc[1, :]
}
```

Для таких ситуаций есть решение - словарь `fake_arguments`! Просто укажите внутри этого словаря нужный аргумент в кавычках и на этапе проверки будет выполнено необходимое преобразование.

Пример (для той задачи, что описывалась выше):

```python
method_name = 'foo'

arguments = {}
fake_arguments = {
    'df': "df.iloc[1, :]"
}
```

**Примечание:** Вы можете задавать и `arguments`, и `fake_arguments` одновременно.

**Важно:** Позиционные аргументы (`__itresume_noname`) на данный момент не поддерживаются в `fake_arguments`.

#### Имя атрибута

Если вам нужно проверить имя атрибута или свойства в классе, то просто укажите его в `attr_name`. Если нет - оставьте пустую строку.

Пример:

```python
class_name = 'Answer'
class_args = {}

attr_name = 'field'
```

В данном примере будет проверяться атрибут `field` в классе `Answer`:

```python
Answer().field
```

**Примечание:** Отличие `method_name` от `attr_name` при указанном `class_name` только в том, что при проверке `method_name` вызывается (т.е. после него добавляются скобки и указанные аргументы), а атрибут прописывается без последующих скобок. Сравните:

```python
Answer().attribute
Answer().method()
```

#### Имя переменной

Если вам нужно просто проверить конкретную переменную, то занесите ее название в `var_name`. Если нет - просто оставьте поле пустым.

**Примечание:** В таком случае предполагается, что вы не будете проверять класс или функцию - вы проверяете только конкретную переменную.

Такие проверки подходят для заданий, где нужно, например:

* считать содержимое файла в переменную
* обработать датафрейм, который описан некоторой переменной
* сделать вычисление и сохранить результат в переменную
* создать объект
* создать экземпляр класса
* написать функцию, вызвать ее и сохранить результат в переменную
* и так далее

Пример:

```python
var_name = 'a'
```

В таком случае тестирующая система будет проверять переменную с именем `a`.

#### Формулировка

Если пользователь провалил какой-то тест, то ему выводится подробная расшифровка - что именно привело к ошибке или неправильному результату. Пользователь видит:

* какая функция/класс/метод/переменная/атрибут проверялись
* какие были аргументы
* как выглядит итоговый код, который отправляется на проверку

Вы можете добавить пояснение от автора, чтобы тест стал еще понятней. Например, написать в явном виде, для чего написан данный тест. Пример:

```python
formulation = "В этом тесте проверяется корректность работы функции foo"
```

В противном случае просто оставьте пустую строку:

```python
formulation = ""
```

#### Нужно ли задавать функцию print

Проверка результата происходит следующим образом:

* запускается эталонный код, результат считывается с помощью функции `print`
* запускается код пользователя, результат считывается с помощью функции `print`
* происходит сравнение

Однако, встречаются задачи, в которых функция `print` и так уже задана в коде. Например:

> Напишите функцию myprint, которая выводит на экран фразу "Hello world"

В таком случае, при написании теста для функции `myprint` нужно указать, что `print` уже есть внутри этой функции и дополнительно его добавлять не нужно. Это можно сделать с помощью флага `need_print`.

По умолчанию он имеет значение `True`. Если вам нужно его поменять, поставьте `False`.

**Важно:** Делайте это только там, где уже в коде пользователя действительно присутствует функцию `print` или ее аналог. Иначе тест будет работать некорректно.

#### Дополнительное преобразование кода пользователя

В некоторых задачах возникает потребность перед проверкой сделать какие-то дополнительные действия, которые позволят проверить код пользователя в более сложных ситуациях. Например:

* Предварительно инициализировать какие-то вспомогательные переменные
* Взять результат, который получил пользователь и как-то его трансформировать

Пару ситуаций, где это может пригодиться:

* Нам нужно проверить атрибут класса, который меняется с каждым созданием экземпляра этого класса. Для корректной проверки нам нужно сначала создать `N` таких экземпляров.
* Пользователь написал функцию, которая возвращает некую переменную. Мы хотим написать тест для проверки - а какой тип данных у этой переменной. Для этого с помощью функции `type` мы можем создать новую переменную, а потом ее уже проверить в `var_name`.
* В задаче предполагается, что пользователь работает с заранее заданными массивами. Однако, у нас не функция и передать эти массивы аргументами мы туда не можем - надо их объявить перед кодом пользователя.

Сделать это можно с помощью аргументов `add_before` и `add_after.`

* Аргумент `add_before` добавляет дополнительный код перед всем кодом, который написал пользователь
* Аргумент `add_after` добавляет в конец, после всего кода

Если добавлять ничего не надо, просто оставьте пустые строки.

**Примечание:** Переносы строки до и после заданного вами кода добавятся сами.

При этом следите, чтобы флаг `reset_state` имел значение `True`. В таком случае в каждом тесте (если в классе `Tests` определено несколько тестов) будет проверяться исходный код, который написал пользователь, а не измененный с помощью `add_before` и `add_after`. Крайне редко его необходимо делать `False` - делайте это только после консультации со специалистом компании IT Resume.

**Пример**

Допустим, в задаче предполагается, что пользователю дано 2 массива - `users` и `coins`. Он должен создать две переменные `len1` и `len2`, записав туда длину каждого из массивов.

Он написал такой код:

```python
len1 = len(users)
len2 = len(coins)
```

Для корректной работы автопроверки нам нужно определить переменные `users` и `coins` перед кодом пользователя. Укажем такие параметры:

```
add_before = """
users = [1, 2, 3]
coins = [4, 5, 6]
"""
```

**Примечание:** Подробнее такие случаи будут рассмотрены в примерах.

#### Нужно ли «вычислять» результат

Дополнительный флаг `need_to_eval` нужно постоянно держать в состоянии `False`. Крайне редко его необходимо делать `True` - делайте это только после консультации со специалистом компании IT Resume.

## Примеры

Примеры автотестов с комментариями вы можете посмотреть в папке `examples`: [**ссылка**](https://github.com/IT-Resume/ut-instructions).